!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ°´æœè¨˜æ†¶å¡å°æˆ° (äººæ©Ÿ VS)</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --card-back: #ff6b6b;
            --card-back-pattern: #ee5253;
            --text-color: #2d3436;
            --accent-player: #0984e3;
            --accent-ai: #d63031;
            --card-size: 70px; /* é è¨­å¡ç‰‡å¤§å° */
            --gap: 10px;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 800px;
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 24px;
            color: #333;
        }

        .scoreboard {
            display: flex;
            justify-content: space-between;
            background: white;
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-weight: bold;
            font-size: 18px;
        }

        .score-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 15px;
            border-radius: 8px;
            transition: background 0.3s;
        }

        .score-box.active {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }

        .player-box { color: var(--accent-player); }
        .player-box.active { background-color: #e3f2fd; border: 2px solid var(--accent-player); }
        
        .ai-box { color: var(--accent-ai); }
        .ai-box.active { background-color: #ffebee; border: 2px solid var(--accent-ai); }

        .turn-indicator {
            margin-top: 10px;
            font-size: 16px;
            height: 20px;
            color: #666;
        }

        /* éŠæˆ²ç¶²æ ¼å€åŸŸ */
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr); /* é è¨­ 8åˆ— x 5è¡Œ = 40å¼µ */
            gap: var(--gap);
            margin: 0 auto;
            perspective: 1000px; /* 3Dç¿»è½‰æ•ˆæœ */
        }

        /* å¡ç‰‡æ¨£å¼ */
        .card {
            width: var(--card-size);
            height: var(--card-size);
            position: relative;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.5s;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .card.flipped {
            transform: rotateY(180deg);
            cursor: default;
        }

        .card.matched {
            opacity: 0.6;
            cursor: default;
            transform: rotateY(180deg) scale(0.95);
        }

        .card-face {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            user-select: none;
            -webkit-user-select: none;
        }

        /* å¡ç‰‡èƒŒé¢ (è“‹èµ·ä¾†çš„æ¨£å­) */
        .card-front {
            background: var(--card-back);
            background-image: repeating-linear-gradient(
                45deg,
                var(--card-back) 0px,
                var(--card-back) 10px,
                var(--card-back-pattern) 10px,
                var(--card-back-pattern) 20px
            );
            transform: rotateY(0deg);
            border: 2px solid white;
        }

        /* å¡ç‰‡æ­£é¢ (ç¿»é–‹å¾Œçš„æ°´æœ) */
        .card-back {
            background: white;
            transform: rotateY(180deg);
            border: 2px solid #ddd;
        }

        /* çµæŸå½ˆçª— */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 90%;
            width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal h2 { margin-top: 0; color: #333; }
        .modal p { font-size: 18px; margin: 20px 0; }
        
        button {
            background-color: var(--accent-player);
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover { background-color: #0769b3; }

        /* RWD éŸ¿æ‡‰å¼èª¿æ•´ */
        @media (max-width: 768px) {
            :root { --card-size: 45px; --gap: 6px; }
            .game-board { grid-template-columns: repeat(5, 1fr); } /* 5åˆ— x 8è¡Œ */
        }

        @media (max-width: 400px) {
            :root { --card-size: 38px; --gap: 4px; }
            .scoreboard { font-size: 14px; padding: 10px; }
            .score-box { padding: 2px 8px; }
            .card-face { font-size: 24px; }
        }
    </style>
</head>
<body>

    <header>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <a href="index.html" style="text-decoration: none; color: #0984e3; font-weight: bold; display: flex; align-items: center; gap: 5px; padding: 8px 15px; border-radius: 20px; background: #e3f2fd; border: 1px solid #0984e3;">
                â† è¿”å›ä¸»é 
            </a>
            <h1 style="margin: 0;">ğŸ§  æ°´æœè¨˜æ†¶å¤§å°æ±º</h1>
            <div style="width: 100px;"></div> <!-- Spacer for balance -->
        </div>
        <div class="scoreboard">
            <div class="score-box player-box" id="player-box">
                <span>ç©å®¶</span>
                <span id="player-score">0</span>
            </div>
            <div class="score-box ai-box" id="ai-box">
                <span>AI é›»è…¦</span>
                <span id="ai-score">0</span>
            </div>
        </div>
        <div class="turn-indicator" id="status-text">æº–å‚™é–‹å§‹...</div>
    </header>

    <main class="game-board" id="game-board">
        <!-- å¡ç‰‡å°‡ç”± JavaScript ç”Ÿæˆ -->
    </main>

    <!-- éŠæˆ²çµæŸå½ˆçª— -->
    <div class="modal-overlay" id="end-modal">
        <div class="modal">
            <h2 id="winner-title">éŠæˆ²çµæŸ</h2>
            <p id="winner-message">çµæœé¡¯ç¤º...</p>
            <button onclick="initGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // --- éŠæˆ²è¨­å®š ---
        const fruits = [
            'ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸ‰', 'ğŸŠ', 
            'ğŸ‹', 'ğŸ', 'ğŸ‘', 'ğŸ’', 'ğŸ“', 
            'ğŸ¥', 'ğŸ…', 'ğŸ¥¥', 'ğŸ¥‘', 'ğŸ†',
            'ğŸ¥”', 'ğŸ¥•', 'ğŸŒ½', 'ğŸ¥¦', 'ğŸ„'
        ]; // 20ç¨®æ°´æœ

        let cardsArray = []; // æ‰€æœ‰å¡ç‰Œè³‡æ–™
        let hasFlippedCard = false;
        let lockBoard = false; // é–å®šé¢æ¿é˜²æ­¢å‹•ç•«ä¸­é»æ“Š
        let firstCard, secondCard;
        
        let playerScore = 0;
        let aiScore = 0;
        let isPlayerTurn = true; // true = ç©å®¶, false = AI
        let totalPairs = 20;
        let matchedPairs = 0;

        // AI è¨˜æ†¶åº«: key = index, value = fruitType
        // ç•¶å¡ç‰‡è¢«ç¿»é–‹æ™‚ï¼ŒAIæœƒè¨˜éŒ„ä¸‹ä¾†
        let aiMemory = new Map(); 

        const boardElement = document.getElementById('game-board');
        const playerScoreEl = document.getElementById('player-score');
        const aiScoreEl = document.getElementById('ai-score');
        const playerBox = document.getElementById('player-box');
        const aiBox = document.getElementById('ai-box');
        const statusText = document.getElementById('status-text');
        const endModal = document.getElementById('end-modal');
        const winnerTitle = document.getElementById('winner-title');
        const winnerMessage = document.getElementById('winner-message');

        // --- åˆå§‹åŒ–éŠæˆ² ---
        function initGame() {
            // é‡ç½®è®Šæ•¸
            playerScore = 0;
            aiScore = 0;
            matchedPairs = 0;
            isPlayerTurn = true; // ç©å®¶å…ˆæ‰‹
            hasFlippedCard = false;
            lockBoard = false;
            firstCard = null;
            secondCard = null;
            aiMemory.clear();
            endModal.classList.remove('show');
            
            // æ›´æ–° UI
            updateScoreUI();
            updateTurnUI();

            // ç”Ÿæˆå¡ç‰Œ
            // å°‡æ°´æœé™£åˆ—è¤‡è£½ä¸€ä»½ï¼Œè®Šæˆ 40 å¼µ
            cardsArray = [...fruits, ...fruits];
            
            // æ´—ç‰Œ (Fisher-Yates ç®—æ³•)
            for (let i = cardsArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cardsArray[i], cardsArray[j]] = [cardsArray[j], cardsArray[i]];
            }

            // æ¸…ç©ºä¸¦é‡å»º DOM
            boardElement.innerHTML = '';
            cardsArray.forEach((fruit, index) => {
                const card = createCardElement(fruit, index);
                boardElement.appendChild(card);
            });
        }

        // --- å»ºç«‹å¡ç‰‡ DOM ---
        function createCardElement(fruit, index) {
            const card = document.createElement('div');
            card.classList.add('card');
            card.dataset.fruit = fruit;
            card.dataset.index = index;

            const frontFace = document.createElement('div');
            frontFace.classList.add('card-face', 'card-front');
            
            const backFace = document.createElement('div');
            backFace.classList.add('card-face', 'card-back');
            backFace.textContent = fruit;

            card.appendChild(frontFace);
            card.appendChild(backFace);

            card.addEventListener('click', flipCard);
            return card;
        }

        // --- ç¿»ç‰Œé‚è¼¯ (ç©å®¶) ---
        function flipCard() {
            // å¦‚æœé¢æ¿é–å®šã€æ­£åœ¨AIå›åˆã€æˆ–é»æ“ŠåŒä¸€å¼µå¡ï¼Œå‰‡å¿½ç•¥
            if (lockBoard) return;
            if (!isPlayerTurn) return;
            if (this === firstCard) return;

            this.classList.add('flipped');

            // è¨˜éŒ„åˆ° AI è¨˜æ†¶ä¸­ (ç©å®¶ç¿»é–‹çš„ï¼ŒAIä¹Ÿçœ‹è¦‹äº†)
            const index = this.dataset.index;
            const fruit = this.dataset.fruit;
            aiMemory.set(index, fruit);

            if (!hasFlippedCard) {
                // ç¬¬ä¸€æ¬¡ç¿»ç‰Œ
                hasFlippedCard = true;
                firstCard = this;
                return;
            }

            // ç¬¬äºŒæ¬¡ç¿»ç‰Œ
            secondCard = this;
            checkForMatch();
        }

        // --- æª¢æŸ¥é…å° ---
        function checkForMatch() {
            let isMatch = firstCard.dataset.fruit === secondCard.dataset.fruit;

            if (isMatch) {
                disableCards();
            } else {
                unflipCards();
            }
        }

        // --- é…å°æˆåŠŸè™•ç† ---
        function disableCards() {
            // æ¨™è¨˜ç‚ºå·²é…å°
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');
            
            // è¨ˆåˆ†
            if (isPlayerTurn) {
                playerScore++;
            } else {
                aiScore++;
            }
            matchedPairs++;
            updateScoreUI();

            // AI è¨˜æ†¶æ›´æ–°: é…å°æˆåŠŸçš„ç‰Œå¯ä»¥å¾è¨˜æ†¶ä¸­ç§»é™¤ï¼Œå› ç‚ºå·²ç¶“æ²’ç”¨äº†
            // (é€™è£¡ä¸ç§»é™¤ä¹Ÿæ²’é—œä¿‚ï¼Œä½†åœ¨é‚è¼¯ä¸Šé€™å…©å¼µç‰Œå·²ç¶“æ˜¯ "å·²çŸ¥ä¸”å·²è§£æ±º")
            aiMemory.delete(firstCard.dataset.index);
            aiMemory.delete(secondCard.dataset.index);

            resetBoard();

            // æª¢æŸ¥éŠæˆ²æ˜¯å¦çµæŸ
            if (matchedPairs === totalPairs) {
                setTimeout(endGame, 500);
            } else {
                // è¦å‰‡ï¼šé…å°æˆåŠŸå¯ä»¥ç¹¼çºŒç¿» (é€£æ“Š)ï¼Œæ‰€ä»¥å›åˆä¸åˆ‡æ›
                statusText.textContent = isPlayerTurn ? "é…å°æˆåŠŸï¼ç¹¼çºŒï¼" : "AI é…å°æˆåŠŸï¼ç¹¼çºŒç¿»ç‰Œï¼";
                
                // å¦‚æœæ˜¯ AI å›åˆä¸”é…å°æˆåŠŸï¼Œç¨å¾Œç¹¼çºŒ AI é‚è¼¯
                if (!isPlayerTurn) {
                    setTimeout(aiTurn, 1000);
                }
            }
        }

        // --- é…å°å¤±æ•—è™•ç† ---
        function unflipCards() {
            lockBoard = true; // é–å®šé¢æ¿ï¼Œé˜²æ­¢äº‚é»

            setTimeout(() => {
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                
                // åˆ‡æ›å›åˆ
                isPlayerTurn = !isPlayerTurn;
                updateTurnUI();
                resetBoard();

                // å¦‚æœæ›åˆ° AI å›åˆ
                if (!isPlayerTurn) {
                    setTimeout(aiTurn, 1000);
                }
            }, 1000);
        }

        // --- é‡ç½®æš«å­˜è®Šæ•¸ ---
        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        // --- UI æ›´æ–° ---
        function updateScoreUI() {
            playerScoreEl.textContent = playerScore;
            aiScoreEl.textContent = aiScore;
        }

        function updateTurnUI() {
            if (isPlayerTurn) {
                playerBox.classList.add('active');
                aiBox.classList.remove('active');
                statusText.textContent = "è¼ªåˆ°ä½ äº†ï¼Œè«‹ç¿»ç‰Œ";
                statusText.style.color = "#0984e3";
            } else {
                playerBox.classList.remove('active');
                aiBox.classList.add('active');
                statusText.textContent = "AI æ­£åœ¨æ€è€ƒ...";
                statusText.style.color = "#d63031";
            }
        }

        // --- éŠæˆ²çµæŸ ---
        function endGame() {
            endModal.classList.add('show');
            if (playerScore > aiScore) {
                winnerTitle.textContent = "ğŸ‰ æ­å–œä½ ç²å‹ï¼";
                winnerMessage.textContent = `ç©å®¶ ${playerScore} : ${aiScore} AI`;
                winnerTitle.style.color = "#0984e3";
            } else if (aiScore > playerScore) {
                winnerTitle.textContent = "ğŸ¤– AI ç²å‹ï¼";
                winnerMessage.textContent = `ç©å®¶ ${playerScore} : ${aiScore} AI`;
                winnerTitle.style.color = "#d63031";
            } else {
                winnerTitle.textContent = "ğŸ¤ å¹³æ‰‹ï¼";
                winnerMessage.textContent = "å¯¦åŠ›ä¸ç›¸ä¸Šä¸‹";
                winnerTitle.style.color = "#636e72";
            }
        }

        // --- AI é‚è¼¯æ ¸å¿ƒ ---
        function aiTurn() {
            if (isPlayerTurn || matchedPairs === totalPairs) return;

            // 1. æº–å‚™ç¬¬ä¸€å¼µç‰Œçš„é¸æ“‡
            let card1Index = pickFirstCard();
            flipCardByIndex(card1Index);

            // 2. æº–å‚™ç¬¬äºŒå¼µç‰Œçš„é¸æ“‡ (éœ€ç­‰ç¬¬ä¸€å¼µç¿»é–‹å¾Œ)
            setTimeout(() => {
                // åŸºæ–¼ç¬¬ä¸€å¼µç‰Œçš„å…§å®¹æ±ºå®šç¬¬äºŒå¼µ
                let card1Fruit = cardsArray[card1Index];
                let card2Index = pickSecondCard(card1Index, card1Fruit);
                flipCardByIndex(card2Index);
            }, 800);
        }

        // è¼”åŠ©ï¼šä¾æ“š Index ç¿»ç‰Œ
        function flipCardByIndex(index) {
            const card = boardElement.children[index];
            // å¦‚æœå¡ç‰‡å·²ç¶“è¢«é…å°(matched)ï¼Œç†è«–ä¸Šä¸æœƒè¢«é¸åˆ°ï¼Œä½†åŠ å€‹ä¿éšª
            if (card.classList.contains('matched')) return;

            // AI è¨˜æ†¶éŒ„å…¥
            aiMemory.set(index, cardsArray[index]);

            // è§¸ç™¼ç¿»ç‰Œå‹•ç•«èˆ‡é‚è¼¯
            card.classList.add('flipped');

            if (!firstCard) {
                firstCard = card;
            } else {
                secondCard = card;
                checkForMatch();
            }
        }

        // AI ç­–ç•¥ 1: æ±ºå®šç¬¬ä¸€å¼µç¿»ä»€éº¼
        function pickFirstCard() {
            // 1. æª¢æŸ¥è¨˜æ†¶ä¸­æ˜¯å¦æœ‰æˆå°çš„ç‰Œ
            let pairIndex = findKnownPair();
            if (pairIndex !== -1) {
                return pairIndex; // ç›´æ¥æ‹¿é€™ä¸€å¼µ
            }

            // 2. æ²’æœ‰æˆå°ï¼Œæª¢æŸ¥è¨˜æ†¶ä¸­æ˜¯å¦æœ‰å–®å¼µå·²çŸ¥çš„ç‰Œ (å˜—è©¦å»æ¹Šå°)
            let knownSingle = findKnownSingle();
            if (knownSingle !== -1) {
                return knownSingle;
            }

            // 3. å®Œå…¨æ²’è¨˜æ†¶ï¼Œéš¨æ©Ÿé¸ä¸€å¼µæ²’ç¿»é–‹çš„
            return getRandomUnknownCard();
        }

        // AI ç­–ç•¥ 2: æ±ºå®šç¬¬äºŒå¼µç¿»ä»€éº¼
        function pickSecondCard(firstIndex, firstFruit) {
            // 1. å¦‚æœçŸ¥é“é€™å¼µç‰Œçš„å¦ä¸€åŠåœ¨å“ªï¼Œç›´æ¥ç¿»
            // éæ­· AI è¨˜æ†¶
            for (let [idx, fruit] of aiMemory) {
                if (idx !== firstIndex && fruit === firstFruit) {
                    return idx; // æ‰¾åˆ°é…å°äº†ï¼
                }
            }

            // 2. ä¸çŸ¥é“å¦ä¸€åŠåœ¨å“ªï¼Œéš¨æ©Ÿé¸ä¸€å¼µæ²’ç¿»é–‹ä¸”ä¸æ˜¯ç¬¬ä¸€å¼µçš„ç‰Œ
            return getRandomUnknownCard(firstIndex);
        }

        // --- AI è¼”åŠ©å‡½æ•¸ ---

        function findKnownPair() {
            // æª¢æŸ¥è¨˜æ†¶åº«ï¼Œçœ‹æ˜¯å¦æœ‰å…©å¼µä¸€æ¨£çš„æ°´æœ
            // ç”¨ä¸€å€‹ Map çµ±è¨ˆè¨˜æ†¶ä¸­çš„æ°´æœæ•¸é‡
            let counts = {};
            for (let [idx, fruit] of aiMemory) {
                // é‚„è¦ç¢ºèªé€™å¼µç‰Œåœ¨æ¿ä¸Šé‚„æ²’è¢« matched (é›–ç„¶ matched çš„æœƒå¾ aiMemory ç§»é™¤ï¼Œä½†é›™é‡ä¿éšª)
                let cardEl = boardElement.children[idx];
                if (cardEl.classList.contains('matched')) continue;

                if (counts[fruit]) {
                    // ç™¼ç¾ç¬¬äºŒå¼µä¸€æ¨£çš„ï¼
                    // counts[fruit] è¨˜éŒ„çš„æ˜¯ç¬¬ä¸€æ¬¡çœ‹åˆ°çš„ index
                    return counts[fruit];
                } else {
                    counts[fruit] = idx;
                }
            }
            return -1;
        }

        function findKnownSingle() {
            // æ‰¾ä¸€å¼µ AI è¨˜å¾—ä½†é‚„æ²’æ‰¾åˆ°é…å°çš„ç‰Œ
            for (let [idx, fruit] of aiMemory) {
                let cardEl = boardElement.children[idx];
                if (!cardEl.classList.contains('flipped') && !cardEl.classList.contains('matched')) {
                    // ç°¡å–®çš„ AI ç­–ç•¥ï¼šå¦‚æœè¨˜å¾—ä¸€å¼µï¼Œå°±å»ç¿»å®ƒå˜—è©¦é‹æ°£
                    return idx;
                }
            }
            return -1;
        }

        function getRandomUnknownCard(excludeIndex = -1) {
            let availableIndices = [];
            for (let i = 0; i < cardsArray.length; i++) {
                let cardEl = boardElement.children[i];
                // æ¢ä»¶ï¼šæ²’è¢«ç¿»é–‹ï¼Œæ²’è¢«é…å°ï¼Œä¸æ˜¯æ’é™¤çš„é‚£å¼µ
                if (!cardEl.classList.contains('flipped') && 
                    !cardEl.classList.contains('matched') && 
                    i !== excludeIndex) {
                    availableIndices.push(i);
                }
            }
            // éš¨æ©Ÿå›å‚³
            if (availableIndices.length === 0) return -1; // ç†è«–ä¸Šä¸æœƒç™¼ç”Ÿ
            return availableIndices[Math.floor(Math.random() * availableIndices.length)];
        }

        // å•Ÿå‹•éŠæˆ²
        initGame();

    </script>
</body>
</html>