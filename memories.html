<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ°´æœè¨˜æ†¶å¡å°æˆ° (é€£æ“Šç‰ˆ)</title>
    <style>
        :root {
            --bg-color: #f0f4f8;
            --card-back: #ff6b6b;
            --card-back-pattern: #ee5253;
            --text-color: #2d3436;
            --accent-player: #0984e3;
            --accent-ai: #d63031;
            --card-size: 70px;
            --gap: 10px;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 800px;
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 24px;
            color: #333;
        }

        .scoreboard {
            display: flex;
            justify-content: space-between;
            background: white;
            padding: 15px 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-weight: bold;
            font-size: 18px;
        }

        .score-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 15px;
            border-radius: 8px;
            transition: background 0.3s;
        }

        .score-box.active {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }

        .player-box { color: var(--accent-player); }
        .player-box.active { background-color: #e3f2fd; border: 2px solid var(--accent-player); }
        
        .ai-box { color: var(--accent-ai); }
        .ai-box.active { background-color: #ffebee; border: 2px solid var(--accent-ai); }

        .turn-indicator {
            margin-top: 10px;
            font-size: 16px;
            height: 20px;
            color: #666;
            font-weight: bold;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--gap);
            margin: 0 auto;
            perspective: 1000px;
        }

        .card {
            width: var(--card-size);
            height: var(--card-size);
            position: relative;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.5s;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .card.flipped { transform: rotateY(180deg); cursor: default; }
        .card.matched {
            opacity: 0.6;
            cursor: default;
            transform: rotateY(180deg) scale(0.95);
        }

        .card-face {
            width: 100%;
            height: 100%;
            position: absolute;
            backface-visibility: hidden;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            user-select: none;
            -webkit-user-select: none;
        }

        .card-front {
            background: var(--card-back);
            background-image: repeating-linear-gradient(
                45deg, var(--card-back) 0px, var(--card-back) 10px,
                var(--card-back-pattern) 10px, var(--card-back-pattern) 20px
            );
            transform: rotateY(0deg);
            border: 2px solid white;
        }

        .card-back {
            background: white;
            transform: rotateY(180deg);
            border: 2px solid #ddd;
        }

        /* Modal æ¨£å¼ */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.show { opacity: 1; pointer-events: auto; }

        .modal {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 90%;
            width: 300px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .modal h2 { margin-top: 0; color: #333; }
        .modal p { font-size: 16px; margin: 20px 0; color: #555; line-height: 1.5;}
        
        button {
            background-color: var(--accent-player);
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover { background-color: #0769b3; }

        @media (max-width: 768px) {
            :root { --card-size: 45px; --gap: 6px; }
            .game-board { grid-template-columns: repeat(5, 1fr); }
        }
        @media (max-width: 400px) {
            :root { --card-size: 38px; --gap: 4px; }
            .scoreboard { font-size: 14px; padding: 10px; }
            .score-box { padding: 2px 8px; }
            .card-face { font-size: 24px; }
        }
    </style>
</head>
<body>

    <header>
        <h1>ğŸ§  æ°´æœè¨˜æ†¶å¤§å°æ±º</h1>
        <div class="scoreboard">
            <div class="score-box player-box" id="player-box">
                <span>ç©å®¶</span>
                <span id="player-score">0</span>
            </div>
            <div class="score-box ai-box" id="ai-box">
                <span>AI é›»è…¦</span>
                <span id="ai-score">0</span>
            </div>
        </div>
        <div class="turn-indicator" id="status-text">æº–å‚™é–‹å§‹...</div>
    </header>

    <main class="game-board" id="game-board"></main>

    <!-- é–‹å§‹ç•«é¢ -->
    <div class="modal-overlay show" id="start-modal">
        <div class="modal">
            <h2>ğŸ§  æ°´æœè¨˜æ†¶å¤§å°æ±º</h2>
            <p>
                <b>è¦å‰‡èªªæ˜ï¼š</b><br>
                1. ç¿»é–‹å…©å¼µç›¸åŒçš„ç‰Œå¾— 1 åˆ†ï¼Œä¸¦å¯<b>ç¹¼çºŒç¿»ç‰Œ</b>ã€‚<br>
                2. ä¸åŒçš„ç‰Œå‰‡æ›å°æ–¹ã€‚<br>
                3. AI è¨˜æ†¶åŠ›ç‚º 60%ï¼Œå®¹æ˜“å¿˜è¨˜ä½ç½®ï¼
            </p>
            <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
        </div>
    </div>

    <!-- çµæŸç•«é¢ -->
    <div class="modal-overlay" id="end-modal">
        <div class="modal">
            <h2 id="winner-title">éŠæˆ²çµæŸ</h2>
            <p id="winner-message">çµæœé¡¯ç¤º...</p>
            <button onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        const fruits = [
            'ğŸ', 'ğŸŒ', 'ğŸ‡', 'ğŸ‰', 'ğŸŠ', 
            'ğŸ‹', 'ğŸ', 'ğŸ‘', 'ğŸ’', 'ğŸ“', 
            'ğŸ¥', 'ğŸ…', 'ğŸ¥¥', 'ğŸ¥‘', 'ğŸ†',
            'ğŸ¥”', 'ğŸ¥•', 'ğŸŒ½', 'ğŸ¥¦', 'ğŸ„'
        ];

        // [è¨­å®š] AI è¨˜æ†¶åŠ› 60% (å³ 40% éºå¿˜ç‡)
        const AI_MEMORY_CHANCE = 0.6; 

        let cardsArray = []; 
        let hasFlippedCard = false;
        let lockBoard = false; 
        let firstCard, secondCard;
        let playerScore = 0;
        let aiScore = 0;
        let isPlayerTurn = true; 
        let totalPairs = 20;
        let matchedPairs = 0;
        let aiMemory = new Map(); 

        const boardElement = document.getElementById('game-board');
        const playerScoreEl = document.getElementById('player-score');
        const aiScoreEl = document.getElementById('ai-score');
        const playerBox = document.getElementById('player-box');
        const aiBox = document.getElementById('ai-box');
        const statusText = document.getElementById('status-text');
        const startModal = document.getElementById('start-modal');
        const endModal = document.getElementById('end-modal');
        const winnerTitle = document.getElementById('winner-title');
        const winnerMessage = document.getElementById('winner-message');

        function startGame() {
            startModal.classList.remove('show');
            initGame();
        }

        function restartGame() {
            endModal.classList.remove('show');
            startModal.classList.add('show');
        }

        function initGame() {
            playerScore = 0; aiScore = 0; matchedPairs = 0;
            isPlayerTurn = true; hasFlippedCard = false; lockBoard = false;
            firstCard = null; secondCard = null;
            aiMemory.clear();
            updateScoreUI(); updateTurnUI();

            cardsArray = [...fruits, ...fruits];
            for (let i = cardsArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cardsArray[i], cardsArray[j]] = [cardsArray[j], cardsArray[i]];
            }

            boardElement.innerHTML = '';
            cardsArray.forEach((fruit, index) => {
                const card = createCardElement(fruit, index);
                boardElement.appendChild(card);
            });
        }

        function createCardElement(fruit, index) {
            const card = document.createElement('div');
            card.classList.add('card');
            card.dataset.fruit = fruit;
            card.dataset.index = index;
            const frontFace = document.createElement('div');
            frontFace.classList.add('card-face', 'card-front');
            const backFace = document.createElement('div');
            backFace.classList.add('card-face', 'card-back');
            backFace.textContent = fruit;
            card.appendChild(frontFace); card.appendChild(backFace);
            card.addEventListener('click', flipCard);
            return card;
        }

        function flipCard() {
            if (lockBoard) return;
            if (!isPlayerTurn) return;
            if (this === firstCard) return;

            this.classList.add('flipped');
            const index = this.dataset.index;
            const fruit = this.dataset.fruit;
            
            // AI è©¦åœ–è¨˜æ†¶
            tryAiRemember(index, fruit);

            if (!hasFlippedCard) {
                hasFlippedCard = true;
                firstCard = this;
                return;
            }
            secondCard = this;
            checkForMatch();
        }

        function tryAiRemember(index, fruit) {
            // åªæœ‰ 60% æ©Ÿç‡è¨˜ä½
            if (Math.random() < AI_MEMORY_CHANCE) {
                aiMemory.set(index, fruit);
            }
        }

        function checkForMatch() {
            let isMatch = firstCard.dataset.fruit === secondCard.dataset.fruit;
            if (isMatch) {
                disableCards();
            } else {
                unflipCards();
            }
        }

        function disableCards() {
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');
            
            if (isPlayerTurn) {
                playerScore++;
            } else {
                aiScore++;
            }
            matchedPairs++;
            updateScoreUI();

            // ç§»é™¤è¨˜æ†¶ä¸­çš„é…å°
            aiMemory.delete(firstCard.dataset.index);
            aiMemory.delete(secondCard.dataset.index);

            resetBoard();

            if (matchedPairs === totalPairs) {
                setTimeout(endGame, 500);
            } else {
                // [é€£æ“Šé‚è¼¯] é…å°æˆåŠŸä¸æ›äººï¼Œç¹¼çºŒ
                statusText.textContent = isPlayerTurn ? "é…å°æˆåŠŸï¼ç¹¼çºŒç¿»ï¼" : "AI é…å°æˆåŠŸï¼ç¹¼çºŒï¼";
                statusText.style.color = "#2ecc71";

                // å¦‚æœæ˜¯ AI é…å°æˆåŠŸï¼Œå»¶é²å¾Œç¹¼çºŒ AI é‚è¼¯
                if (!isPlayerTurn) {
                    setTimeout(aiTurn, 1200);
                }
            }
        }

        function unflipCards() {
            lockBoard = true;
            setTimeout(() => {
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                
                // é…å°å¤±æ•—ï¼Œæ›äºº
                isPlayerTurn = !isPlayerTurn;
                updateTurnUI();
                resetBoard();

                if (!isPlayerTurn) {
                    setTimeout(aiTurn, 1000);
                }
            }, 1000);
        }

        function resetBoard() {
            [hasFlippedCard, lockBoard] = [false, false];
            [firstCard, secondCard] = [null, null];
        }

        function updateScoreUI() {
            playerScoreEl.textContent = playerScore;
            aiScoreEl.textContent = aiScore;
        }

        function updateTurnUI() {
            if (isPlayerTurn) {
                playerBox.classList.add('active');
                aiBox.classList.remove('active');
                statusText.textContent = "è¼ªåˆ°ä½ äº†ï¼Œè«‹ç¿»ç‰Œ";
                statusText.style.color = "#0984e3";
            } else {
                playerBox.classList.remove('active');
                aiBox.classList.add('active');
                statusText.textContent = "AI æ­£åœ¨æ€è€ƒ...";
                statusText.style.color = "#d63031";
            }
        }

        function endGame() {
            endModal.classList.add('show');
            if (playerScore > aiScore) {
                winnerTitle.textContent = "ğŸ‰ æ­å–œä½ ç²å‹ï¼";
                winnerMessage.textContent = `ç©å®¶ ${playerScore} : ${aiScore} AI`;
                winnerTitle.style.color = "#0984e3";
            } else if (aiScore > playerScore) {
                winnerTitle.textContent = "ğŸ¤– AI ç²å‹ï¼";
                winnerMessage.textContent = `ç©å®¶ ${playerScore} : ${aiScore} AI`;
                winnerTitle.style.color = "#d63031";
            } else {
                winnerTitle.textContent = "ğŸ¤ å¹³æ‰‹ï¼";
                winnerMessage.textContent = "å¯¦åŠ›ä¸ç›¸ä¸Šä¸‹";
                winnerTitle.style.color = "#636e72";
            }
        }

        // --- AI é‚è¼¯ ---
        function aiTurn() {
            if (isPlayerTurn || matchedPairs === totalPairs) return;

            let card1Index = pickFirstCard();
            flipCardByIndex(card1Index);

            setTimeout(() => {
                if (isPlayerTurn) return; 
                let card1Fruit = cardsArray[card1Index];
                let card2Index = pickSecondCard(card1Index, card1Fruit);
                if (card2Index === -1) {
                    card2Index = getRandomUnknownCard(card1Index);
                }
                flipCardByIndex(card2Index);
            }, 800);
        }

        function flipCardByIndex(index) {
            const card = boardElement.children[index];
            if (!card || card.classList.contains('matched')) return;

            tryAiRemember(index, cardsArray[index]);
            card.classList.add('flipped');

            if (!firstCard) {
                firstCard = card;
            } else {
                secondCard = card;
                checkForMatch();
            }
        }

        function pickFirstCard() {
            let pairIndex = findKnownPair();
            if (pairIndex !== -1) return pairIndex;

            let knownSingle = findKnownSingle();
            if (knownSingle !== -1) return knownSingle;

            return getRandomUnknownCard();
        }

        function pickSecondCard(firstIndex, firstFruit) {
            for (let [idx, fruit] of aiMemory) {
                let cardEl = boardElement.children[idx];
                if (idx !== firstIndex && 
                    fruit === firstFruit && 
                    !cardEl.classList.contains('matched')) {
                    return idx; 
                }
            }
            return getRandomUnknownCard(firstIndex);
        }

        function findKnownPair() {
            let counts = {};
            for (let [idx, fruit] of aiMemory) {
                let cardEl = boardElement.children[idx];
                if (cardEl.classList.contains('matched')) continue;
                if (counts[fruit]) return counts[fruit];
                else counts[fruit] = idx;
            }
            return -1;
        }

        function findKnownSingle() {
            for (let [idx, fruit] of aiMemory) {
                let cardEl = boardElement.children[idx];
                if (!cardEl.classList.contains('flipped') && !cardEl.classList.contains('matched')) {
                    return idx;
                }
            }
            return -1;
        }

        function getRandomUnknownCard(excludeIndex = -1) {
            let availableIndices = [];
            for (let i = 0; i < cardsArray.length; i++) {
                let cardEl = boardElement.children[i];
                if (!cardEl.classList.contains('flipped') && 
                    !cardEl.classList.contains('matched') && 
                    i !== excludeIndex) {
                    availableIndices.push(i);
                }
            }
            if (availableIndices.length === 0) return -1;
            return availableIndices[Math.floor(Math.random() * availableIndices.length)];
        }
    </script>
</body>
</html>